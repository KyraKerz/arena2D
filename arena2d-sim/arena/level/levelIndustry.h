#ifndef LEVEL_INDUSTRY_H
#define LEVEL_INDUSTRY_H

#include "level.h"
#include "wanderer.h"

#define WANDERER_DEFAULT_SAFETY_DISTANCE 1

// constants for human wanderer
#define WANDERER_ID_HUMAN 0
#define WANDERER_HUMAN_SIZE 0.1
#define WANDERER_HUMAN_VELOCITY 0.2
#define WANDERER_HUMAN_SAFETY_DISTANCE 0.5

// constants for robot wanderer
#define WANDERER_ID_ROBOT 1
#define WANDERER_ROBOT_SIZE 0.2
#define WANDERER_ROBOT_VELOCITY 0.1
#define WANDERER_ROBOT_SAFETY_DISTANCE 0.1

class LevelIndustry : public Level // every custom level must inherit from class Level
{
public:
	/* constructor */
	LevelIndustry(b2World * w) : Level(w, Level::INDUSTRY)
	{
		// get level size from settings
		float half_level_size = _SETTINGS->stage.level_size/2.f; 

		// create border around level
		createBorder(b2Vec2(half_level_size, half_level_size));

		// create spawn area for goal
		float goal_radius = _SETTINGS->stage.goal_size/2.f;
		float half_spawn_area_size = half_level_size-goal_radius;
		addRectToSpawnArea(zRect(0, 0, half_spawn_area_size, half_spawn_area_size));
		calculateSpawnArea();// always call this function when done adding shapes to spawn area!

		// adding a human wanderer
		_wanderers.push_back(new Wanderer(	w, WANDERER_HUMAN_SIZE,
											b2Vec2(0,0),
											WANDERER_HUMAN_VELOCITY,
											0.1, 0.2, /* direction change rate, stop rate*/
											WANDERER_ID_HUMAN));
		
		// adding a robot wanderer
		_wanderers.push_back(new Wanderer(	w, WANDERER_ROBOT_SIZE,
										    b2Vec2(0,0),
											WANDERER_ROBOT_VELOCITY,
											0.1, 0.0, /* direction change rate, stop rate */
											WANDERER_ID_ROBOT));
	}

	/* destructor */
	~LevelIndustry() override{
		freeWanderers();
	}

	/* free wanderer */
	void freeWanderers(){
		// free all wanderers
		for(int i = 0; i < _wanderers.size(); i++){
			delete(_wanderers[i]);
		}
		_wanderers.clear();
	}

	/* reset
	 * called initially when level is loaded and whenever robot hits an obstacle or reaches goal
	 * @param robot_position is the current position of the robot
	 * @param hard_reset true if hard reset was triggered (robot hits obstacle or flag 'enable_position_reset' in settings is set)
	 */
	void reset(b2Vec2 & robot_position, bool hard_reset) override{
		// respawn goal at random location in goal spawn area
		randomGoalSpawnUntilValid(robot_position);

		// resetting positions of wanderers so they dont collide with robot initially
		if(hard_reset){
			_wanderers[0]->reset(b2Vec2(-1, 0));
			_wanderers[1]->reset(b2Vec2(1, 0));
		}
	}

	/* update
	 * called after every physics simulation step
	 */
	void update(const b2Transform & robot_transform) override{
		// updating all wanderers -> this adjusts the wanderers moving direction
		for(int i = 0; i < _wanderers.size(); i++){
			_wanderers[i]->update();
		}

		// calculate closest wanderer
		calculateClosestWanderer(robot_transform);
	}

	/* getAgentData
	 * provide the agent with additional data generated by this level
	 * @param robot_transform current position and orientation of the robot
	 * @param data arbitrary data can be pushed into this vector that will be appended at the end of the default observation [goal_position, laser_data, additional_data] and given to the agent as observation
	 */
	void getAgentData(const b2Transform & robot_transform, std::vector<float> & data) override{
		// pushing it all into data
		data.push_back(_closestDistance);		// distance to closest
		data.push_back(_closestAngle);			// angle to closest (relative from robot)
		data.push_back(_closestSafetyDistance);	// safety distance for closest
	}

	/* getReward
	 * provide additional rewards/penalties
	 */
	float getReward(const b2Transform & robot_transform){
		if(_closestDistance < _closestSafetyDistance){
			return -1;
		}
		else{
			return 0;
		}
	}

private:
	/* calculate closest wanderer distance, angle and safety distance from given robot position
	 */
	void calculateClosestWanderer(const b2Transform & robot_transform){
		Wanderer* closest_wanderer = NULL;
		_closestDistance = 1000;
		_closestAngle = 0;
		_closestSafetyDistance = WANDERER_DEFAULT_SAFETY_DISTANCE;
		float min_l = 1000;
		// getting closest wanderer
		for(int i = 0; i < _wanderers.size(); i++){
			// calculate distance from (_wanderers[i]+safetyDistance) to robot
			float l = (_wanderers[i]->getPosition() - robot_transform.p).Length()-BURGER_SAFE_RADIUS - _wanderers[i]->getRadius();

			// get safety distance to current wanderer
			float safety_distance =  getSafetyDistanceFromWandererID(_wanderers[i]->getID());
			if(l-safety_distance < min_l){// new closest considering safety distance?
				closest_wanderer = _wanderers[i];
				_closestDistance = l;
				min_l = l-safety_distance;
				_closestSafetyDistance = safety_distance;
			}
		}

		// closest wanderer found?
		if(closest_wanderer != NULL){
			// calculate angle from robot to closest obstacle
			zVector2D robot_facing(1, 0);
			robot_facing.rotate(robot_transform.q.GetAngle());// robot facing vector
			b2Vec2 robot_to_wanderer = closest_wanderer->getPosition()-robot_transform.p;// vector from robot to wanderer
			_closestAngle = f_deg(zVector2D::signedAngle(robot_facing, zVector2D(robot_to_wanderer.x, robot_to_wanderer.y)));// angle between robot facing vector and robot to wanderer
		}
	}
	/* get safety distance from given wanderer id
	 */
	float getSafetyDistanceFromWandererID(int id){
			switch(id){
				case WANDERER_ID_HUMAN: {
					return WANDERER_HUMAN_SAFETY_DISTANCE;
				}break;
				case WANDERER_ID_ROBOT: {
					return WANDERER_ROBOT_SAFETY_DISTANCE;	
				}break;
				default:
					return WANDERER_DEFAULT_SAFETY_DISTANCE;
			}
	}

	// private variables
	std::vector<Wanderer*> _wanderers; // moving obstacles
	float _closestDistance; // current distance from robot to closest wanderer
	float _closestAngle; // current angle from robot to closest wanderer
	float _closestSafetyDistance; // current safety distance the robot needs to closest wanderer keep in order to not receive negative rewards
};

#endif
